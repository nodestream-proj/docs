"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[5753],{5231:(e,n,r)=>{r.r(n),r.d(n,{assets:()=>o,contentTitle:()=>d,default:()=>c,frontMatter:()=>s,metadata:()=>a,toc:()=>l});var t=r(4848),i=r(8453);const s={},d="Interpreting",a={id:"reference/interpreting",title:"Interpreting",description:"API Details for the Interpreter, Interpretations, and related components.",source:"@site/docs/reference/interpreting.md",sourceDirName:"reference",slug:"/reference/interpreting",permalink:"/docs/docs/reference/interpreting",draft:!1,unlisted:!1,editUrl:"https://github.com/nodesteram-proj/docs/tree/main/packages/create-docusaurus/templates/shared/docs/reference/interpreting.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Filters",permalink:"/docs/docs/reference/filters"},next:{title:"Object Storage",permalink:"/docs/docs/reference/object-storage"}},o={},l=[{value:"Interpreter",id:"interpreter",level:2},{value:"Interpretations",id:"interpretations",level:2},{value:"Source Node Interpretation",id:"source-node-interpretation",level:3},{value:"Example",id:"example",level:4},{value:"Relationship Interpretation",id:"relationship-interpretation",level:3},{value:"Example",id:"example-1",level:4},{value:"Properties Interpretation",id:"properties-interpretation",level:3},{value:"Example",id:"example-2",level:4},{value:"Variables Interpretation",id:"variables-interpretation",level:3},{value:"Switch Interpretation",id:"switch-interpretation",level:3},{value:"Source Node and Relationship Interpretation Combined",id:"source-node-and-relationship-interpretation-combined",level:3},{value:"Given: Source node does not exist in the graph",id:"given-source-node-does-not-exist-in-the-graph",level:4},{value:"Given: Source node already exists in the graph",id:"given-source-node-already-exists-in-the-graph",level:4},{value:"Normalizers",id:"normalizers",level:2},{value:"ValueProviders",id:"valueproviders",level:2},{value:"<code>!jmespath</code>",id:"jmespath",level:3},{value:"<code>!variable</code>",id:"variable",level:3},{value:"<code>!format</code>",id:"format",level:3},{value:"<code>!regex</code>",id:"regex",level:3},{value:"<code>!split</code>",id:"split",level:3},{value:"<code>!normalize</code>",id:"normalize",level:3}];function h(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",p:"p",pre:"pre",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",...(0,i.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(n.h1,{id:"interpreting",children:"Interpreting"}),"\n",(0,t.jsx)(n.p,{children:"API Details for the Interpreter, Interpretations, and related components."}),"\n",(0,t.jsx)(n.h2,{id:"interpreter",children:"Interpreter"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"Interpreter"})," is a pipeline step that takes the data from the previous step and interprets it into nodes and relationships."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Key"}),(0,t.jsx)(n.th,{children:"Description"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Default"}),(0,t.jsx)(n.th,{children:"Required"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"interpretations"})}),(0,t.jsx)(n.td,{children:"A list of interpretations to be used to interpret the data."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"List[Interpretation]"})}),(0,t.jsx)(n.td,{children:"N/A"}),(0,t.jsx)(n.td,{children:"Yes"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"iterate_on"})}),(0,t.jsx)(n.td,{children:"Values to iterate over to interpret the data."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"ValueProvider"})}),(0,t.jsx)(n.td,{children:"N/A"}),(0,t.jsx)(n.td,{children:"No"})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"before_iteration"})}),(0,t.jsx)(n.td,{children:"A list of iterpretations that are applied before iteration."}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"List[Interpretation]"})}),(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"[]"})}),(0,t.jsx)(n.td,{children:"No"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"interpretations",children:"Interpretations"}),"\n",(0,t.jsxs)(n.p,{children:["Interpretations are the building blocks of the ",(0,t.jsx)(n.code,{children:"Interpreter"}),". They are used to interpret the data into nodes and relationships."]}),"\n",(0,t.jsx)(n.h3,{id:"source-node-interpretation",children:"Source Node Interpretation"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"SourceNodeInterpretation"})," is used to interpret the data into a source node."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter Name"}),(0,t.jsx)(n.th,{children:"Required?"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"node_type"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"String or ValueProvider"}),(0,t.jsx)(n.td,{children:"Specifies the type of the source node. It is a required field. When a  ValueProvider is used dynamic index creation and schema introspection are not supported."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"key"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsx)(n.td,{children:"Contains key-value pairs that define the key of the source node.  The keys represent field names, and the values can be either static values or value providers.  It is a required field."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"allow_create"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Boolean"}),(0,t.jsxs)(n.td,{children:["When ",(0,t.jsx)(n.code,{children:"true"}),", allows creating new nodes when source node is not in the graph. When ",(0,t.jsx)(n.code,{children:"false"}),", new source nodes will not be added to the graph. This field is optional and the default value is ",(0,t.jsx)(n.code,{children:"true"}),"."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"properties"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsx)(n.td,{children:"Stores additional properties of the source node. It is a dictionary  where the keys represent property names, and the values can be either  static values or value providers. This field is optional."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"additional_indexes"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"List[String]"}),(0,t.jsx)(n.td,{children:"Specifies additional indexes for desired on the source node. It is a list of field names. This field is optional."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"additional_types"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"List[String]"}),(0,t.jsx)(n.td,{children:"Defines additional types for the source node. It is a list of strings representing the additional types.  These types are not considered by ingestion system as part of the identity of the node and rather considered as  extra labels applied after the ingestion of the node is completed.  This field is optional."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"normalization"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsxs)(n.td,{children:["Contains normalization flags that should be adopted by value providers when getting values. This field is optional. ",(0,t.jsx)(n.a,{href:"#normalizers",children:"See the normalization reference"}),".  By default ",(0,t.jsx)(n.code,{children:"do_lowercase_strings"})," is enabled."]})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"example",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- type: source_node\n  node_type: Person\n  key:\n    name: !jmespath patient_name\n  properties:\n    birthday: !jmespath patient_birthday\n  additional_indexes:\n    - birthday\n  additional_types:\n    - Patient\n"})}),"\n",(0,t.jsx)(n.h3,{id:"relationship-interpretation",children:"Relationship Interpretation"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter Name"}),(0,t.jsx)(n.th,{children:"Required?"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"node_type"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"String or ValueProvider"}),(0,t.jsx)(n.td,{children:"Specifies the type of the node a relationship connects to. It is a required field. When a ValueProvider is used dynamic index creation and schema introspection are not supported."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"relationship_type"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"String or ValueProvider"}),(0,t.jsx)(n.td,{children:"Specifies the type of the relationship. It is a required field. When a ValueProvider is used dynamic index creation and schema introspection are not supported."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"node_key"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsx)(n.td,{children:"Contains key-value pairs that define the key of the related node. The keys represent field names, and the values can be either static values or value providers. It is a required field."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"node_properties"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsx)(n.td,{children:"Stores additional properties of the related node. It is a dictionary where the keys represent property names, and the values can be either static values or value providers. This field is optional."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"relationship_key"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsx)(n.td,{children:"Contains key-value pairs that define the key of the relationship itself. The keys represent field names, and the values can be either static values or value providers. It is a required field. The uniqueness of the relationship is defined in terms of the nodes it is relating and the key of the relationship."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"relationship_properties"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsx)(n.td,{children:"Stores additional properties of the relationship It is a dictionary where the keys represent property names, and the values can be either static values or value providers. This field is optional."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"outbound"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Boolean"}),(0,t.jsx)(n.td,{children:"Represents whether or not the relationship direction is outbound from the source node. By default, this is true."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"find_many"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Boolean"}),(0,t.jsx)(n.td,{children:"Represents whether or not the searches provided to node_key can return multiple values, and thus should create multiple relationships to multiple related nodes."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"iterate_on"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"ValueProvider"}),(0,t.jsx)(n.td,{children:"Iterates over the values provided by the supplied value provider, and creates an relationship for each one."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"node_creation_rule"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsxs)(n.td,{children:[(0,t.jsx)(n.code,{children:"EAGER"})," | ",(0,t.jsx)(n.code,{children:"MATCH_ONLY"})," | ",(0,t.jsx)(n.code,{children:"FUZZY"})]}),(0,t.jsxs)(n.td,{children:["Defaults to ",(0,t.jsx)(n.code,{children:"EAGER"}),". When ",(0,t.jsx)(n.code,{children:"EAGER"}),", related nodes will be created when not present based on the supplied node type and key. ",(0,t.jsx)(n.code,{children:"MATCH_ONLY"})," will not create a relationship when the related node does not already exists. ",(0,t.jsx)(n.code,{children:"FUZZY"})," behaves like ",(0,t.jsx)(n.code,{children:"MATCH ONLY"}),", but treats the key values as regular expressions to match on."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"key_normalization"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsxs)(n.td,{children:["Contains normalization flags that should be adopted by value providers when getting values for node and relationship keys. This field is optional. ",(0,t.jsx)(n.a,{href:"#normalizers",children:"See the normalization reference"}),".  By default  ",(0,t.jsx)(n.code,{children:"do_lowercase_strings"})," is enabled."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"property_normalization"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsxs)(n.td,{children:["Contains normalization flags that should be adopted by value providers when getting values for node and relationship properties. This field is optional. ",(0,t.jsx)(n.a,{href:"#normalizers",children:"See the normalization reference"}),". By default no flags are enabled."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"node_additional_types"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"List[String]"}),(0,t.jsx)(n.td,{children:"Defines additional types for the related node. It is a list of strings representing the additional types. These types are not considered by the ingestion system as part of the identity of the node and rather considered as extra labels applied after the ingestion of the node is completed. This field is optional."})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"example-1",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- type: relationship\n  node_type: Person\n  relationship_type: HAS_CHILD\n  iterate_on: !jmespath children[*]\n  node_key:\n    name: !jmespath name\n"})}),"\n",(0,t.jsxs)(n.p,{children:["See Also: ",(0,t.jsx)(n.a,{href:"#source-node-and-relationship-interpretation-combined",children:"Source Node and Relationship Interpretation Combined"})]}),"\n",(0,t.jsx)(n.h3,{id:"properties-interpretation",children:"Properties Interpretation"}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter Name"}),(0,t.jsx)(n.th,{children:"Required?"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"properties"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsx)(n.td,{children:"Stores additional properties of the source node. It is a dictionary where the keys represent property names, and the values can be either static values or value providers. This field is optional."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"normalization"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsxs)(n.td,{children:["Contains normalization flags that should be adopted by value providers when getting values. This field is optional. ",(0,t.jsx)(n.a,{href:"#normalizers",children:"See the normalization reference"}),".  By default no flags are enabled."]})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"example-2",children:"Example"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- type: properties\n  properties:\n    meaning_of_life: 42\n"})}),"\n",(0,t.jsx)(n.h3,{id:"variables-interpretation",children:"Variables Interpretation"}),"\n",(0,t.jsxs)(n.p,{children:["The variables interpretation is used to define variables that can be referenced later with the ",(0,t.jsx)(n.a,{href:"#variable",children:(0,t.jsx)(n.code,{children:"!variable"})})," value provider.\nFor example, if we wanted to define a variable called ",(0,t.jsx)(n.code,{children:"meaning_of_life"})," with a value of ",(0,t.jsx)(n.code,{children:"42"}),", we would use the following interpretation:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- type: variables\n  variables:\n    meaning_of_life: 42\n"})}),"\n",(0,t.jsx)(n.p,{children:"And it could be referenced later like this:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- type: properties\n  properties:\n    meaning_of_life: !variable meaning_of_life\n"})}),"\n",(0,t.jsx)(n.p,{children:"NOTE: that variables can be defined either statically or using a value provider."}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter Name"}),(0,t.jsx)(n.th,{children:"Required?"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"variables"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsxs)(n.td,{children:["Stores values as variables that can be referenced later with the ",(0,t.jsx)(n.a,{href:"#variable",children:(0,t.jsx)(n.code,{children:"!variable"})})," value provider. It is a dictionary where the keys represent property names, and the values can be either static values or value providers. This field is optional."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"normalization"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsxs)(n.td,{children:["Contains normalization flags that should be adopted by value providers when getting values. This field is optional. ",(0,t.jsx)(n.a,{href:"#normalizers",children:"See the normalization reference"}),".  By default no flags are enabled."]})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"switch-interpretation",children:"Switch Interpretation"}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"SwitchInterpretation"})," is used to switch between different interpretations based on the value of a field."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Parameter Name"}),(0,t.jsx)(n.th,{children:"Required?"}),(0,t.jsx)(n.th,{children:"Type"}),(0,t.jsx)(n.th,{children:"Description"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"switch_on"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"ValueProvider"}),(0,t.jsx)(n.td,{children:"The value provider that will be evaluated for each source node. The value of the value provider will be used to determine which interpretation to apply."})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"interpretations"}),(0,t.jsx)(n.td,{children:"Yes"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsxs)(n.td,{children:["Contains the interpretations that will be applied. The keys represent the values of the ",(0,t.jsx)(n.code,{children:"switch_on"})," parameter. The values represent the interpretations that will be applied. Each value may also be a list of interpretations."]})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:"default"}),(0,t.jsx)(n.td,{children:"No"}),(0,t.jsx)(n.td,{children:"Dictionary"}),(0,t.jsxs)(n.td,{children:["Contains the default interpretation that will be applied if no interpretation has the same value as the value of the ",(0,t.jsx)(n.code,{children:"switch_on"})," parameter."]})]})]})]}),"\n",(0,t.jsx)(n.h3,{id:"source-node-and-relationship-interpretation-combined",children:"Source Node and Relationship Interpretation Combined"}),"\n",(0,t.jsx)(n.p,{children:"A common use case is to combine source node and relationship interpretation."}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n    - type: source_node\n      node_type: Person\n      key:\n        name: !jmespath name\n      allow_create: true\n    - type: relationship\n      node_type: Person\n      relationship_type: HAS_CHILD\n      node_creation_rule: MATCH_ONLY\n      iterate_on: !jmespath children[*]\n      node_key:\n        name: !jmespath name\n"})}),"\n",(0,t.jsxs)(n.p,{children:["In this example, ",(0,t.jsx)(n.code,{children:"source_node"})," has the flag ",(0,t.jsx)(n.code,{children:"allow_create=true"})," while the\nrelationship has ",(0,t.jsx)(n.code,{children:"node_creation_rule=MATCH_ONLY"}),". This means ",(0,t.jsx)(n.code,{children:"Person"}),"\nnodes will be created if they don't already exist using the ",(0,t.jsx)(n.code,{children:"source_node"})," interpretation,\nbut the children ",(0,t.jsx)(n.code,{children:"Person"})," nodes will not be created as part of the ",(0,t.jsx)(n.code,{children:"relationship"})," interpretation.\nThe ",(0,t.jsx)(n.code,{children:"relationship"})," interpretation will only create the relationships between existing persons."]}),"\n",(0,t.jsx)(n.p,{children:"Below is a comprehensive list of possible behaviors depending on pipeline configuration and graph state:"}),"\n",(0,t.jsx)(n.h4,{id:"given-source-node-does-not-exist-in-the-graph",children:"Given: Source node does not exist in the graph"}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsxs)("thead",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{rowspan:"2"}),(0,t.jsx)("th",{rowspan:"2"}),(0,t.jsx)("th",{colspan:"2",children:"Related Node"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Already Exists"}),(0,t.jsx)("th",{children:"Does Not Exist"})]})]}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowspan:"2",children:"source_node.allow_create=true"}),(0,t.jsx)("td",{children:"relationship.node_creation_rule=EAGER"}),(0,t.jsx)("td",{children:"Source Node and Relationship are created"}),(0,t.jsx)("td",{children:"Everything is created"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"relationship.node_creation_rule=MATCH_ONLY"}),(0,t.jsx)("td",{children:"Source Node and Relationship are created"}),(0,t.jsx)("td",{children:"Source Node is created"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowspan:"2",children:"source_node.allow_create=false"}),(0,t.jsx)("td",{children:"relationship.node_creation_rule=EAGER"}),(0,t.jsx)("td",{children:"Nothing is created"}),(0,t.jsx)("td",{children:"Related node is created"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"relationship.node_creation_rule=MATCH_ONLY"}),(0,t.jsx)("td",{children:"Nothing is created"}),(0,t.jsx)("td",{children:"Nothing is created"})]})]})]}),"\n",(0,t.jsx)(n.h4,{id:"given-source-node-already-exists-in-the-graph",children:"Given: Source node already exists in the graph"}),"\n",(0,t.jsxs)("table",{children:[(0,t.jsxs)("thead",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{rowspan:"2"}),(0,t.jsx)("th",{rowspan:"2"}),(0,t.jsx)("th",{colspan:"2",children:"Related Node"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("th",{children:"Already Exists"}),(0,t.jsx)("th",{children:"Does Not Exist"})]})]}),(0,t.jsxs)("tbody",{children:[(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowspan:"2",children:"source_node.allow_create=true"}),(0,t.jsx)("td",{children:"relationship.node_creation_rule=EAGER"}),(0,t.jsx)("td",{children:"Relationship is created"}),(0,t.jsx)("td",{children:"Related Node and Relationship are created"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"relationship.node_creation_rule=MATCH_ONLY"}),(0,t.jsx)("td",{children:"Relationship is created"}),(0,t.jsx)("td",{children:"Nothing is created"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{rowspan:"2",children:"source_node.allow_create=false"}),(0,t.jsx)("td",{children:"relationship.node_creation_rule=EAGER"}),(0,t.jsx)("td",{children:"Relationship is created"}),(0,t.jsx)("td",{children:"Related Node and Relationship are created"})]}),(0,t.jsxs)("tr",{children:[(0,t.jsx)("td",{children:"relationship.node_creation_rule=MATCH_ONLY"}),(0,t.jsx)("td",{children:"Relationship is created"}),(0,t.jsx)("td",{children:"Nothing is created"})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"normalizers",children:"Normalizers"}),"\n",(0,t.jsxs)(n.p,{children:["A ",(0,t.jsx)(n.code,{children:"Normalizer"})," allows you to clean data extracted by a ",(0,t.jsx)(n.a,{href:"#valueproviders",children:(0,t.jsx)(n.code,{children:"ValueProvider"})}),".\nThey are intended to provided stateless, simple transformations of data. Many different interpretations allow you to\nenable ",(0,t.jsx)(n.code,{children:"Normalizers"})," to apply these transformations. See the ",(0,t.jsx)(n.a,{href:"../interpreting",children:(0,t.jsx)(n.code,{children:"Interpretation"})})," reference for where\nthey can be applied."]}),"\n",(0,t.jsxs)(n.table,{children:[(0,t.jsx)(n.thead,{children:(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.th,{children:"Normalizer Flag Name"}),(0,t.jsx)(n.th,{children:"Example Input"}),(0,t.jsx)(n.th,{children:"Example Output"})]})}),(0,t.jsxs)(n.tbody,{children:[(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"do_lowercase_strings"})}),(0,t.jsx)(n.td,{children:'"dO_LoWER_cASe_strings"'}),(0,t.jsx)(n.td,{children:'"do_lowercase_strings"'})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"do_remove_trailing_dots"})}),(0,t.jsx)(n.td,{children:'"my.website.com."'}),(0,t.jsx)(n.td,{children:'"my.website.com"'})]}),(0,t.jsxs)(n.tr,{children:[(0,t.jsx)(n.td,{children:(0,t.jsx)(n.code,{children:"do_trim_whitespace"})}),(0,t.jsx)(n.td,{children:'"  some value "'}),(0,t.jsx)(n.td,{children:'"some value"'})]})]})]}),"\n",(0,t.jsx)(n.h2,{id:"valueproviders",children:"ValueProviders"}),"\n",(0,t.jsx)(n.h3,{id:"jmespath",children:(0,t.jsx)(n.code,{children:"!jmespath"})}),"\n",(0,t.jsxs)(n.p,{children:["Represents a ",(0,t.jsx)(n.a,{href:"https://jmespath.org/",children:"jmespath"})," query language expression that should be executed against the input record."]}),"\n",(0,t.jsxs)(n.p,{children:["For example, if you want to get extract all of the ",(0,t.jsx)(n.code,{children:"name"})," fields from the list of people provided in a document like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "people": [{"name": "Joe", "age": 25}, {"name": "john", "age": 45}]\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["A valid ",(0,t.jsx)(n.code,{children:"!jmespath"})," value provider would look like this: ",(0,t.jsx)(n.code,{children:"!jmespath people[*].name"})," Essentially, any ",(0,t.jsx)(n.code,{children:"jmespath"})," expression\nprovided after the ",(0,t.jsx)(n.code,{children:"!jmespath"})," tag will be parsed and loaded as one. Another guide on ",(0,t.jsx)(n.code,{children:"jmespath"})," can be found ",(0,t.jsx)(n.a,{href:"https://jmespath.site/main/",children:"here"}),"."]}),"\n",(0,t.jsx)(n.h3,{id:"variable",children:(0,t.jsx)(n.code,{children:"!variable"})}),"\n",(0,t.jsxs)(n.p,{children:["Provides the value of an extracted variable from the ",(0,t.jsx)(n.a,{href:"#variables-interpretation",children:"Variables Interpretation"}),". For instance, if\nyou provided an variables interpretation block like so:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"interpretations:\n    - type: variables\n      variables:\n         name: !jmespath person.name\n"})}),"\n",(0,t.jsxs)(n.p,{children:["You are then able to use the ",(0,t.jsx)(n.code,{children:"!variable"})," provided in a later interpretation. For example,"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"interpretations:\n    # other interpretations are omitted.\n    - type: source_node\n      node_type: Person\n         name: !variable name\n"})}),"\n",(0,t.jsxs)(n.p,{children:["This is particularly helpful when using the ",(0,t.jsx)(n.code,{children:"before_iteration"})," and ",(0,t.jsx)(n.code,{children:"iterate_on"})," clause in an ",(0,t.jsx)(n.code,{children:"Interpreter"}),". For example,\nassume that you have a record that looks like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "team_name": "My Awesome Team",\n    "people": [\n        {"name": "Joe", "age": 25},\n        {"name": "John", "age": 34},\n    ]\n}\n'})}),"\n",(0,t.jsx)(n.p,{children:"On way to ingest this data would be to do the following:"}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    before_iteration:\n      - type: variables\n        variables:\n           team: !jmespath team\n    iterate_on: !jmespath people[]\n    interpretations:\n      - type: source_node\n        node_type: Person\n        key:\n          name: !jmespath name\n        properties:\n          age: !jmespath age\n      - type: relationship\n        node_type: Team\n        relationship_type: PART_OF\n        node_key:\n          name: !variable team\n"})}),"\n",(0,t.jsx)(n.h3,{id:"format",children:(0,t.jsx)(n.code,{children:"!format"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"!format"})," value provider allows you to format a string using the ",(0,t.jsx)(n.code,{children:"format"})," method. For example, if you wanted to create a hello world\nnode based on a name field in the record, you could do the following:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "name": "Joe",\n    "age": 25\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The following interpretation would create a node with the key ",(0,t.jsx)(n.code,{children:"Hello, Joe!"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: source_node\n        node_type: HelloNode\n        key:\n          name: !format\n            fmt: "Hello, {name}!"\n            name: !jmespath name\n        properties:\n          age: !jmespath age\n'})}),"\n",(0,t.jsx)(n.h3,{id:"regex",children:(0,t.jsx)(n.code,{children:"!regex"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"!regex"})," value provider allows you to extract a value from a string using a regular expression. For example, if you wanted to extract\nthe first name from a string given a record like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "name": "Joe Smith",\n    "age": 25\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The following interpretation would create a node with the key ",(0,t.jsx)(n.code,{children:"Joe"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: source_node\n        node_type: HelloNode\n        key:\n          first_name: !regex\n            regex: "^(?P<first_name>[a-zA-Z]+)\\s(?P<last_name>[a-zA-Z]+)$"\n            data: !jmespath name\n            group: first_name\n        properties:\n          age: !jmespath age\n'})}),"\n",(0,t.jsxs)(n.p,{children:["You can either use named groups or numbered groups.\nIf you use named groups, you can specify the group name in the ",(0,t.jsx)(n.code,{children:"group"})," argument.\nIf you use numbered groups, you can specify the group number in the ",(0,t.jsx)(n.code,{children:"group"})," argument.\nIf you do not specify a group, the first group will be used - which is the entire match."]}),"\n",(0,t.jsx)(n.h3,{id:"split",children:(0,t.jsx)(n.code,{children:"!split"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"!split"})," value provider allows you to split a string into a list of strings using a delimiter. For example, if you wanted to split a string like this:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "name": "Joe Smith",\n    "talents": "jumping,running,swimming"\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The following interpretations would create a ",(0,t.jsx)(n.code,{children:"Joe Smith"})," node with relationships to ",(0,t.jsx)(n.code,{children:"jumping"}),", ",(0,t.jsx)(n.code,{children:"running"}),", and ",(0,t.jsx)(n.code,{children:"swimming"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:'- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: source_node\n        node_type: Person\n        key:\n          name: !jmespath name\n      - type: relationship\n        node_type: Talent\n        relationship_type: HAS_TALENT\n        find_many: true\n        node_key:\n          name: !split\n            data: !jmespath talents\n            delimiter: ","\n'})}),"\n",(0,t.jsx)(n.h3,{id:"normalize",children:(0,t.jsx)(n.code,{children:"!normalize"})}),"\n",(0,t.jsxs)(n.p,{children:["The ",(0,t.jsx)(n.code,{children:"!normalize"})," value provider allows you to utilize the ",(0,t.jsx)(n.a,{href:"#normalizers",children:"normalization"})," functionality to normalize an incoming value.\nFor example, if you wanted to normalize a name field in the record:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "name": "Joe Smith   ",\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The following interpretation would create a node with the key ",(0,t.jsx)(n.code,{children:"Joe Smith"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: source_node\n        node_type: Person\n        key:\n          name: !normalize\n            using: trim_whitespace\n            data: !jmespath name\n"})}),"\n",(0,t.jsxs)(n.p,{children:["While most interpretations support a ",(0,t.jsx)(n.code,{children:"normalization"})," block (See the ",(0,t.jsx)(n.a,{href:"#interpretations",children:"Interpretations reference above"})," for more information),\nthe ",(0,t.jsx)(n.code,{children:"!normalize"})," value provider allows you to normalize a value before it is returned to the interpretation.\nThis is useful when you want to normalize a value in a ",(0,t.jsx)(n.code,{children:"key"})," or ",(0,t.jsx)(n.code,{children:"property"})," block where the ",(0,t.jsx)(n.code,{children:"normalization"}),"\nshould only be applied to that value only.  For example, if you wanted to normalize the ",(0,t.jsx)(n.code,{children:"city"})," field of the record but not the ",(0,t.jsx)(n.code,{children:"state"})," field:"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-json",children:'{\n    "city": "New York   ",\n    "state": "NY"\n}\n'})}),"\n",(0,t.jsxs)(n.p,{children:["The following interpretation would create a ",(0,t.jsx)(n.code,{children:"Locality"})," node with the keys of ",(0,t.jsx)(n.code,{children:"New York"})," and ",(0,t.jsx)(n.code,{children:"NY"}),":"]}),"\n",(0,t.jsx)(n.pre,{children:(0,t.jsx)(n.code,{className:"language-yaml",children:"- implementation: nodestream.interpreting:Interpreter\n  arguments:\n    interpretations:\n      - type: source_node\n        node_type: Locality\n        key:\n          city: !normalize\n            using: trim_whitespace\n            data: !jmespath city\n          state: !jmespath state\n"})})]})}function c(e={}){const{wrapper:n}={...(0,i.R)(),...e.components};return n?(0,t.jsx)(n,{...e,children:(0,t.jsx)(h,{...e})}):h(e)}},8453:(e,n,r)=>{r.d(n,{R:()=>d,x:()=>a});var t=r(6540);const i={},s=t.createContext(i);function d(e){const n=t.useContext(s);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:d(e.components),t.createElement(s.Provider,{value:n},e.children)}}}]);